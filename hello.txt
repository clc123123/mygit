Maven 是当前最受欢迎的JAVA项目管理构建自动化综合工具
----------------------------------------------------------------
 Aoo o = new Boo();
  o.show();-----------Boo
Aoo o = new Boo(); //向上造型
		//重载时，看类型
		//重写时，看对象
  身份证编号的验证
        \d{17}[0-9Xx]$,
        ^(\d)$就是0-9的任意一个数字，
        ^表示以...开头，\d表示0-9的数字，$表示以...结尾，
        最后，这个式子的最简单形式是\[\d+\]
在编程语言中的字符串形式是"\\[\\d+\\]"



cut()方法----多态的
cut是多态的
a是引用;引用指向对象

一个类型的引用在指向不同的对象时有不同的功能
人 a = new 理发师();
人 b = new 外科医生();
人 c = new 演员();     //向上造型
a.cut();-----剪发
b.cut();-----开刀
c.cut();-----停止表演

同一个对象，造型成不同的类型时，具有不同的功能
我的多态的
  讲师--------------授课
  儿子他妈----------打他
  我妈的女儿--------发火
  老公我老婆--------打他、发火

讲师 a       = new 我();
儿子妈妈 b   = new 我();
老公的老婆 c = new 我();  //向上造型

a.授课();
b.打他();
c.揍他();
c.发火();

匿名内部类就是没有名字的内部类；
匿名内部类不能定义任何静态成员、方法s。
匿名内部类中的方法不能是抽象的；
匿内部类必须实现接口或抽象父类的所有抽象方法。
匿名内部类访问的外部类成员变量或成员方法必须用static修饰；

面向对象3大特征:
1.封装:保证安全
    类-------封装数据、行为
        作为一个整体操作
    方法-----封装功能的实现
        隐藏实现的细节
    访问修饰符----控制访问权限
        保证数据的安全
2.继承:实现代码的重用
    extends
3.多态:多种形态，在继承的基础之上
       提高可维护性、可扩展性
    1)一个类型指向不同对象，有不同的实现
    2)同一个对象造型成不同类型时，有不同的功能
-------------------------------------------------------------------------------


model业务层,包括了业务逻辑和数据访问逻辑,封装好给我i视图层使用
view试图层,仅仅做的是展示数据,不包括业务逻辑,主要是jsp/html
controller,控制层,负责接受请求,调用模型层处理业务逻辑并返回视图层

什么是MVC?
MVC是经典的设计模式,是代码的分层思想
M:model,业务层,用来处理业务,业务逻辑+数据访问逻辑
V:view,视图层,用来展现数据
C:contoller,控制层,用来调度,是业务层和视图层的桥梁.

如何分层(MVC)
##表示层:数据展现和控制逻辑(请求分发)
##业务层:业务逻辑的处理
##持久层:数据访问
M拆分为业务层和持久层,vc加起来变成表示层
(上面三层调用的时候带接口的好处)
a.上一层通过接口调用下一层提供的服务.
比如,业务层调用持久层提供的接口.
b.下一层发送改变,不影响上一层.方便维护.
实现接口,依据接口的要求来设计

### login.jsp,index.jsp ,LoginController
#########调用##############
###LoginServlice接口,LoginServiceImpl类
###########调用###########
###AdminDAO接口,AdminDAOJdbcImpl类 dao包  
Resource(name="ds")
//注入连接池,位于AdminDAOJdbcImpl类 下
private DataSource ds;
然后就可以在器它方法里面调用连接池变量
public Admin findByAdminCode(String adminCode){
  Admin admin=null;
  Connection conn=null;
  try{
     conn=ds.getConnection();
  }catch(SQLException e){ 
   //记日志(保留现场)
   e.printStackTrace();
   //看异常是否能恢复
   
  }finally{
  }
  return admin; 
}

}


Admin类   entity包
DBUtils类    util包 ,连接池版本的数据库,管理工具
db.properties  Resource包 
c3p0是一个喜欢星球大战的人开发的连接池


设计接口是为了方便依赖注入
B要注入到A,要实现b的接口

依赖注入:把别人的类加进来Resource

将代码解耦,便于团队开发维护
Java代码的三层:
controller:控制层,负责接收参数/解析参数/封装参数,调用service,将service的方法的返回值进行封装
service:负责业务逻辑,十五控制在这层做,被controller调用,以及调用dao
dao:持久层,负责数据库交互
---------------------------------------------------------------------------------------------
反射:java的动态执行机制,可以用invoke访问私有方法.
调反射api,从class开始
Class cls=Class.forName(className);
反射能够调用私有方法
method.setAccessible(true); 

day02
Mybatis是一个半ORM（对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。
Mybaits的优点：

（1）基于SQL语句编程，相当灵活，不会对应用程序或者数据库的现有设计造成任何影响，SQL写在XML里，解除sql与程序代码的耦合，便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用。

（2）与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接；

（3）很好的与各种数据库兼容（因为MyBatis使用JDBC来连接数据库，所以只要JDBC支持的数据库MyBatis都支持）。

（4）能够与Spring很好的集成；

（5）提供映射标签，支持对象与数据库的ORM字段关系映射；提供对象关系映射标签，支持对象关系组件维护
----------------------------------------------------------------------------------------------
day03


所谓“持久层”，也就是在系统逻辑层面上，专注于实现数据持久化的一个相对独立的领域(Domain)，是把数据保存到可掉电式存储设备中。持久层是负责向（或者从）一个或者多个数据存储器中存储（或者获取）数据的一组类和组件。

SSH
Structs ++ Hibernate +Spring

SSM
SpringMVC + MyBatis+Spring 

Servlet -> JSP -> Spring -> 组合框架
(组件,动态拼资源,处理http协议  )
(servlet拼网页太繁琐了,servlet上线一年后就被取代了,而且
jsp不需要配置,里面能写很多东西
不需要写servlet,但是只能写小东西,而且java代码和标签耦合在一起model1模式,只有servlet/jsp,Dao,DB只用一个组件处理请求)
(servlet+jsp+dao+DB,引用了MVC设计模式对代码进行分层,降低耦合度,java代码和标签分开
MVC是经典的设计模式,是代码的分层思想
将代码解耦,便于团队开发维护
)
PreparedStatement
 执行计划
---------------------------------------------------------------------------------
day04
事务简介
-原子性:要么做,要么不做
-一致性:食物在完成时,必须使所有数据爆出一致性
-隔离性:修改与修改要隔离
-持久性:做了就是永久影响
事务是数据库的概念,JDBC,支持事务,本质还是在数据库中实现


ps:
1.怎么看世界,世界就怎么看你
2.沟通是一件好能力


框架与设计模式虽然相似，但却有着根本的不同。设计模式是对在某种环境中反复出现的问题以及解决该问题的方案的描述，它比框架更抽象；框架可以用代码表示，也能直接执行或复用，而对模式而言只有实例才能用代码表示;设计模式是比框架更小的元素，一个框架中往往含有一个或多个设计模式，框架总是针对某一特定应用领域，但同一模式却可适用于各种应用。可以说，框架是软件，而设计模式是软件的知识。
框架模式有哪些？
MVC、MTV、MVP、CBD、ORM等等；
框架有哪些？
C++语言的QT、MFC、gtk，Java语言的SSH 、SSI，php语言的 smarty(MVC模式)，python语言的django(MTV模式)等等
设计模式有哪些？
工厂模式、适配器模式、策略模式等等
简而言之：框架是大智慧，用来对软件设计进行分工；设计模式是小技巧，对具体问题提出解决方案，以提高代码复用率，降低耦合度。


DBCP(DataBase Connection Pool)数据库连接池

int A::test()//表示test是属于A的

硬编码就是在程序中将代码写死
不好的是如果以后这些要变动，就得重新改代码了，比较麻烦
特别是对一些可配置的信息，不要硬编码

持久层框架编辑
Hibernate
MyBatis
也就是说hibernate和mybatis很像,都是处理数据库的
-------------------------------------------------------------------------------------------
day05
Mapper代理的开发方式，程序员只需要编写mapper接口（相当于dao接口）即可。Mybatis会自动的为mapper接口生成动态代理实现类。(我目前是创建了mapper包,包下面有mapper映射文件和mapper接口)

Mybatis 的映射文件
输入映射ParameterType
简单类型 int
POJO对象 user
POJO包装类  UserQueryVO

步骤1.在映射文件.xml编写sql标签语
2.在接口里面定义
1,2可以颠倒
3.测试
------------------------------------------------------------------------------------------------
day06
数据库持久层框架有哪些
	DBUtils,spring-data,mybatis,hibernate

spring 继承mybatis
struts fliter的过滤器
hibernate 查询 也和mybatis有关
 补充:
parameterType和resultType
parameterType指定输入参数的java类型，可以填写别名或Java类的全限定名。
resultType指定输出结果的java类型，可以填写别名或Java类的全限定名。

#{}和${}
#{}：相当于预处理中的占位符？。
#{}里面的参数表示接收java输入参数的名称。
#{}可以接受HashMap、POJO类型的参数。
当接受简单类型的参数时，#{}里面可以是value，也可以是其他。
#{}可以防止SQL注入。
${}：相当于拼接SQL串，对传入的值不做任何解释的原样输出。
${}会引起SQL注入，所以要谨慎使用。
${}可以接受HashMap、POJO类型的参数。
当接受简单类型的参数时，${}里面只能是value。

${}会引起SQL注入，一般情况下不推荐使用。但是有些场景必须使用${}，比如order by ${colname}
	-->
	<selectid="findUserByName"parameterType="String"resultType="com.gyf.domain.User">
		SELECT * FROM USER WHERE username like '%${value}%'
select * from user r where username like '%${user.username}%'

% ：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示。

数据库——自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接
natural join
inner join
outer join
-right outer join
-left outer join
cross join 

框架
spring struts hiberation
spring springmvc mybatis
我们在实际应用中发现，SpringMVC可以完全替代Struts，配合注解的方式，编程非常快捷，而且通过restful风格定义url，让地址看起来非常优雅。
另外，MyBatis也可以替换Hibernate，正因为MyBatis的半自动特点，我们程序猿可以完全掌控SQL，这会让有数据库经验的程序猿能开发出高效率的SQL语句，而且XML配置管理起来也非常方便。


Spring在SSM起什么作用

Spring是一个轻量级框架，也是一个容器，Spring实质上讲就是一个Bean工厂，主要用来管理Bean的生命周期和框架集成。有IOC控制反转，DI依赖注入，控制反转是把dao依赖注入到servic层，然后service层反转给action层，Spring的顶层容器为BeanFactory，常用的ApplicationContext为它的子接口，实现了工厂模式，Spring还提供了AOP的支持，方便在切面级开发
----------------------------------------------------------------------------------------------
day07
开发规范
1.mapper接口的全限定名要和mapper映射文件的namespace的值相同。
2.mapper接口的方法名称要和mapper映射文件中的statement的id相同；
3.mapper接口的方法参数只能有一个，且类型要和mapper映射文件中statement的parameterType的值保持一致。
4.mapper接口的返回值类型要和mapper映射文件中statement的resultType值或resultMap中的type值保持一致；

好烦
这几天打算回顾一下jsp+servlet方面的知识
===========================
.程序员应聘必备词汇：了解＝听过名字；熟悉＝知道是啥；熟练＝用过；精通＝做过东西



https://aip.baidubce.com/oauth/2.0/token?grant_type=client_credentials&client_id=2VHCDKTCozFZiWoZ2t8QqIvD&client_secret=tZBv3pGv9d3CSHbBTqYry3DgEzxeBCLj

24.ed9a754eca5a31c8f4d44cc6559afd3c.2592000.1566785501.282335-16895884

https://www.daixiehw.com/

我的手机 2019/7/29 10:36:22
admin/Xiong169907877


mysql.driver=com.mysql.jdbc.Driver
mysql.url=jdbc:mysql://localhost:3306/clc?useSSL=false
mysql.user=root
mysql.password=123456

23.65亿

day07-htmlday01
span标签
用于在行内设定一个块区域。
Html中绝大多数元素被定义为块级元素或内联元素。
块级元素在浏览器显示时，通常会以新行来开始。例如 div p等
内联元素在浏览器显示时，通常不会以新行来开始。Span
<div>标记的会换行,参数有align
p是段落,br是换行,hr生成水平线
align:设置水平线对齐方式 left right,center
	Html的数值默认单位为像素(px).
	在有些位置可以使用百分比来设置。
例如:
<hr size=’3’>这个就代表水平线厚席为3px.
<hr width=’30%’>这个就代表水平线长度为总长度的30%.
h1-h6
<h1>-<h6>标签用于定义标题.
h1>最大标题
<h6>最小标题
ul是无序的,li是列表项,ol是有序列表

table
 thead用于定义表格的页眉tfoot页脚tbody表格主题
        caption表格标题
        tr用于定于表格里面的行,包括th或者td元素
        td定义表格单元,td元素的文本一般正常且左对齐
        th定义表格的表头,内部是居中且加粗

  method=get或者 post 可以携带大量数据,并且不会在地址栏上显示数据
     name定义表单的名称
    action 向何处发送表单数据
    包含input,input用于搜集用户信息,里面有
    <input type="text">
    <input type="password">
    <input type="radio"> 单选
    <input type="checkbox">复选
    <input type="button">
    <input type="hidden">隐藏的输入手段
    <input type="file">
    <input type="submit">
    <input type=”image”>

?	multiple:定义可选择多个选项
?	<option>用于定义下拉列表中的选项。
?	<option>需要位于<select>标签内部
?	常用属性:
?	value:定义送往服务器的选项值
?	selected:定义选项为选中状态。
===========================================
css层叠样式表
样式存放在.css 文件或者区域里面
?	把样式添加到 HTML 4.0 中，是为了解决内容与表现分离的问题
?	外部样式表可以极大提高工作效率
?	外部样式表通常存储在 CSS 文件中
?	多个样式定义可层叠为一
?	Css规则主要由两部分组成 1.选择器2.一条或多条属性声明
?	选择器主要作用是为了确定需要改变样式的HTML元素
?	如果值为若干单词，则要给值加引号
?	多个声明之间使用分号(;)分开

    <style type="text/css">
        span{color: red;}
        </style>
</head>
<body>
<div style="border: 1px solid red;">这是一个Div</div>
<span>内部样式表</span>
</body>
3外联样式表就是加一个<link>标签导入外部样式表
<link rel="stylesheet" type="text/css" href="./这里放你的css样式">
4.外部导入@import
<style type="text/css"> @import "mystyle.css" </style>

#-id
.-class
<!--id选择器-->
<style type="text/css">
    #div1{
        background-color:gray ;
        width: 1000px;
        height: 100px;
    }
</style>
<div id="div1">这也是一个Div</div>

类选择器就是把#换成.  id对应的换成class <div class="div3">这也是一个Div</div>
类选择器使用时,需要在类名前加一个点号(.)
?	项目中，绝大部都是用类选择器排版



元素选择器最有意思 最常见.简单说，文档中的元素就是选择器
<style type="text/css">
    div{
        background-color:gray ;
        width: 1000px;
        height: 100px;
    }
</style>
</head>
<body>
<div >这也是一个Div</div>

属性选择器
<style type="text/css">
   input[type='text']{
        background-color:gray ;
        width: 1000px;
        height: 100px;
    }
</style>
</head>
<body>
<input type="text" placeholder="输入内容">  //只有这个才会生效
<input type="password">
<input type="button" value="提交">

伪类   css伪类用于向某些选择器添加特殊效果
<style type="text/css">
a:visited{color:blue;}   //访问后的状态
a:active{color:green}  //点击状态
a:link {color:purple}  //普通状态
a:hover{color:black}
</style>
</head>
<body>
<a href="网址"> </a>


------------------------------------------------------------------------------
day08-htmlday02
字体:Css字体属性定义文本的字体系列，大小，加粗，风格(如斜体)和变形(如小型大写字母)
常用属性:
?font:简写属性，作用是把所有针对字体的属性设置在一个声明中。【style size family】
?font-family:定义字体系列
?font-size:定义字体的尺寸
?font-style:定义字体风格


文本:CSS 文本属性可定义文本的外观。通过文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等。
常用属性
?color:定义文本颜色
?text-align:定义文本对齐方式
?letter-spacing:定义字符间隔

背景:CSS 允许应用纯色作为背景，也允许使用背景图像创建相当复杂的效果。CSS 在这方面的能力远远在 HTML 之上。
常用属性:
?background:简写属性，作用是将背景属性设置在一个声明中
?background-color:定义背景颜色
?background-image:定义背景图片
?background-position:定义背景图片的起始位置【left,center,right】
?background-repeat:定义背景图片是否及如何重复

以上用的都是id选择器
下面用的都是类选择器
列表:CSS 列表属性允许你放置、改变列表项标志，或者将图像作为列表项标志。<ul>  <li></li> </ul>
常用属性:
?list-style:简写属性。用于把所有用于列表的属性设置于一个声明中。
?list-style-image:定义列表项标志为图象
?list-style-position:定义列表项标志的位置
?list-style-type:定义列表项标志的类型。

表格:CSS 表格属性可以帮助您极大地改善表格的外观<table>
常用属性:
?border-collapse:定义是否把表格边框合并为单一的边框。
?border-spacing:定义分隔单元格边框的距离
?caption-side:定义表格标题的位置【top,bottom】

轮廓（outline）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。
?CSS outline 属性规定元素轮廓的样式、颜色和宽度。
常用属性:
?outline:在一个声明中设置所有的轮廓属性
?outline-color:定义轮廓的颜色
?outline-style:定义轮廓的样式
?outline-width:定义轮廓的宽度
在<head>的<style>的table{}选择器里面加上outline:

定位:CSS 定位 (Positioning) 属性允许你对元素进行定位。
?定位的基本思想很简单，它允许你定义元素框相对于其正常位置应该出现的位置，或者相对于父元素、另一个元素甚至浏览器窗口本身的位置
?CSS 有三种基本的定位机制：普通流、浮动和绝对定位。
?常用属性:
??position:把元素放置到一个静态的,相对的，绝对的，或固定的位置中。
??top:定义了定位元素的上外边距边界与其包含块上边界之间的偏移量
?   right: 定义了定位元素右外边距边界与其包含块右边界之间的偏移
?   left: 定义了定位元素左外边距边界与其包含块左边界之间的偏移
??bottom: 定义了定位元素下外边距边界与其包含块下边界之间的偏移。


分类:CSS 分类属性允许你控制如何显示元素，设置图像显示于另一元素中的何处，相对于其正常位置来定位元素，使用绝对值来定位元素，以及元素的可见度。
?常用属性
?clear:设置一个元素的侧面是否允许其它的浮动元素
?float:定义元素在哪个方向浮动
?cursor:当指向某元素之上时显示的指针类型
?display:定义是否及如何显示元素
?visibility:定义元素是否可见或不可见


CSS 框模型 (Box Model) 规定了元素框处理元素内容、内边距、边框 和 外边距 的方式。

边框:
?元素的边框 (border) 是围绕元素内容和内边距的一条或多条线。
?CSS border 属性允许你规定元素边框的样式、宽度和颜色。
?常用属性:
?border:简写属性，用于把针对于四个边的属性设置在一个声明。
?border-color:简写属性，定义元素边框中可见部分的颜色，或为四个边分别设置颜色。
?border-style:用于定义所有边框的样式，或者单独为各边设置边框样式。
?border-width:简写属性，用于为元素的所有边框设置宽度，或则单独地为各边边框设置宽度
?border-top:简写属性，用于把上边框的所有属性设置到一个声明中
?border-right:简写属性，用于把右边框所有属性设置到一个声明中
?border-bottom:简写属性，用于把下边框的所有属性设置到一个声明中
?border-left:简写属性，用于把左边框的所有属性设置到一个声明中。


外边距
margin:在一个声明中设置所有的外边距属性

内边距
padding:在一个声明中设置元素的所有内边距
--------------------------------------------
   javaScript 是因特网上最流行的脚本语言，它存在于全世界所有 Web 浏览器中，能够增强用户与 Web 站点和 Web 应用程序之间的交互。
?脚本语言：脚本语言又被称为扩建的语言，或者动态语言，是一种解释型语言，由解释器来运行，用来控制软件应用程序，脚本通常以文本保存，只在被调用时进行解释或编译
   JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行。
?JavaScript 与 Java 是两种完全不同的语言
?我们通过javascript可以改变html内容,改变html样式,进行验证输入等

第一种:在html页面中直接插入javascript
注意:<script>标签可以出现在html页面的任意位置，但实际操作中，一般会写在<head>标签中
第二种:引入外部的javascript
?有时，你也许希望在若干个页面中运行 JavaScript，同时不在每个页面中写相同的脚本。
?为了达到这个目的，你可以将 JavaScript 写入一个外部文件之中。然后以 .js 为后缀保存这个文件。
?注意:
?外部的js文件中不能包含<script>标签。
?在导入外部js文件的<script>标签中不能在写javascript代码。

javascipt 变量是用处存储信息的容器
var 加变量名来定义
 var i=10;
<script>
 var a=null;
 alert(typeof(a));
</script>
null居然是占位符

?引用类型通常叫做类(class),也就是说，遇到引用值，所处理的就是对象
?对象是由 new 运算符加上要实例化的对象的名字创建的var obj=new Object();
?常用的javascript对象:Boolean,Number,Array,String,Date,Math,RegExp.
?可以使用instanceof运算符来判断对象的类型


--------------------------
html与xml区别：
?html语法松散，xml语法严格
?html做页面展示，xml做数据存储(配置文件)
?html所有标签都是预定义的，xml所有标签都是自定义的


-------------------------------------------------------------------------------------
day09-html-day03
maven 本地仓库配置
E:\apache-maven-3.6.1\bin\mvn install:install-file -Dfile=C:\Users\86173\Desktop\java-sdk-master\aip-java-sdk-4.11.3.jar -DgroupId=com.baidu.aip  -DartifactId=java-sdk   -Dversion=4.11.3   -Dpackaging=jar


F:\apache-maven-3.5.0\bin\mvn install:install-file -Dfile=F:\repository\org\exceltools\exceltools\1.0.0\exceltools-1.0.0.jar -DgroupId=org.exceltools  -DartifactId=exceltools   -Dversion=1.0.0   -Dpackaging=jar


打开并加载图片文件的函数
def get_file_content(filePath):   #这样只要获得文件名就能够进行识别
    with open(filePath, 'rb') as fp:  
        return fp.read()

for root, dirs, files in os.walk(".", topdown=False):  # 该迭代类型每单元返回三个部分，我们需要的文件名在第三部分，具体参数自行了解
    for name in files:???????????# name即为文件夹下每个文件的文件名
        if 'png' in name:  ????# 判断是否为图片格式，笔者这里设置png因为常用QQ截图，可自行添加其他格式
            filePath = os.path.join(root, name)[2:]   # 记录下的文件名有./.前缀，所以从第二位为我们需要的filepath
            options = {  
              'detect_direction': 'true',  
              'language_type': 'CHN_ENG',  
            }  
            result = aipOcr.webImage(get_file_content(filePath),options)????#通过filepath打开并识图
            for i in result['words_result']:???????# result为字典类型，识别出的文字信息存放在'words_result'对应的字典中
                print(i['words'])???????#列表中接着嵌套字典，每一部分信息存储在'words'键中??
----------------------------------------------------------------------------------------------
day11
Json
完善了识别的文字
其他似乎啥都没有做.......
------------------------------------------------------------------------------------------------
day12
想要开发一个动态web资源,及开发一个Java程序向浏览器输出数据,要完成2个步骤:
-编写一个Java类,实现servlet接口.
-把开发好的Java类部署到web服务器中
------------------------------------------------------------------------------------------------

day13
Web服务器收到客户端的http请求，会针对每一次请求，分别创建一个用于代表请求的request对象、和代表响应的response对象。

响应正文（主体）
getWrite(); 字符输出流
getOutputStream(); 字节输出流

常见的状态码参照：http://tool.oschina.net/commons?type=5
404请求失败，请求所希望得到的资源未被在服务器上发现
200请求已成功，请求所希望的响应头或数据体将随此响应返回。
302 重定向
500 服务抛出异常


请求重定向指：一个web资源收到客户端请求后，通知客户端去访问另外一个web资源，这称之为请求重定向。
重定向特点：地址栏会变，并发送2次请求，增加服务器负担
实现方式
response.sendRedirect()
实现原理：
302/307状态码和location头即可实现重定向

会话:理解为xxx打开一个浏览器,点击多个超链接,访问服务器多个web资源,然后关闭浏览器,这个过程就是一个会话.

会话过程中要解决的一些问题？
每个用户在使用浏览器与服务器进行会话的过程中，不可避免各自会产生一些数据，程序要想办法为每个用户保存这些数据。

例如：用户点击超链接通过一个servlet购买了一个商品，程序应该想办法保存用户购买的商品，以便于用户点结帐servlet时，结帐servlet可以得到用户购买的商品为用户结帐。

Cookie
Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务器中的web资源时，就会带着各自的数据去。这样，web资源处理的就是用户各自的数据了。

Session
Session是服务器端技术，利用这个技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的HttpSession对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户再去访问服务器中的其它web资源时，其它web资源再从用户各自的session中取出数据为用户服务.


Cookie细节
?一个Cookie只能标识一种信息,它至少含有一个标识该信息的名称（NAME）和设置值（VALUE）。 
?一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。
?浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。
?如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie（即存储在浏览器的内存中），用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。将最大时效设为0则是命令浏览器删除该cookie。


什么是HttpSession？

? ? ? ? HttpSession是由JavaWeb提供的，用来会话跟踪的类。javax.servlet.http.HttpSession接口表示一个会话，我们可以把一个会话内需要共享的数据保存到HttSession对象中！session是服务器端对象，保存在服务器端。会话范围在用户从首次访问服务器开始，到该用户关闭浏览器结束！



HTML页面是静态页面，也就是事先由用户写好放在服务器上，固定内容，不会变，由web服务器向客户端发送，平时上网看的网页都是大部分都是基于html语言的。JSP页面是有JSP容器执行该页面的Java代码部分然后实时生成的动态页面，可动态更新页面上的内容。

为什么要持久化Session
持久化的优点：
节约内存空间；
确保在服务器重启或单个Web应用重启后，能回复重启前的会话；

持久化状态转化
Session在其生命周期中，可能会在运行时状态和持久化状态之间转换。

搁置
会话从运行时状态变为持久化状态的过程称为 —— 搁置；
在以下情况下，Session会被搁置：
当服务器重启或单个Web应用终止时，Web应用中的Session会被搁置；
会话处于不活动状态的时间太长，达到了特定的限定值；
Web应用中处于运行状态的会话数目太多，达到了特定的限制值，部分Session被搁置
===========================

js即 Javascript .是一种编程语言，编程语言是独立于平台，环境的。语言好比我们说的国语，粤语，只不过javascript是机器能懂的，可编程性的语言。js可以写前端（js与html,css结合），也可以写后端（如：node）
jsp 即 JavaServer Pages. 是一种web后端技术，可以响应客户端（如：浏览器）请求，动态生成HTML、XML或其他格式文档的Web网页的技术标准。jsp技术是以Java语言作为脚本语言的，可使用java这种编程语言来进行编程的。


--------------------------------------------------------------------------------------------
day15

jsp的最佳实践
Servlet 控制器,重点编写java代码逻辑(获取表单数据,出路业务逻辑,分发转向)
JSP 代码显示模板,重点在于显示数据

终于成功运行了jsp文件,,,,,,,,2019/8/1
小脚本 <% java代码 %>
JSP注释：<%-- 被注释的内容 --%> 特点：安全，省流量
网页注释：<!-- 网页注释 -->    特点：不安全，费流量
也就是左右加两个-- --


<%@ 指令名称 属性1=“属性值1” 属性2=“属性值2”。。。%>

<%@ page contentType="text/html;charset=UTF-8" language="java" %>

include
静态包含：把其它资源包含到当前页面中。
<%@ include file="xxxx.jsp" %>
动态包含：
<jsp:include page="xxxx.jsp"></jsp:include>

两者的区别：翻译的时间段不同
前者：在翻译时就把两个文件合并
后者：不会合并文件，当代码执行到include时，才包含另一个文件的内容。
原则：能用静的就不用动的。


Taglib 
作用：在JSP页面中导入JSTL标签库。替换jsp中的java代码片段。
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c" %>


JSP的EL表达式
EL概述,expression language 表达式语言,用于简化jsp的java代码开发
不是开发语言,而是jsp中获取数据的一种规范

1.只能获取存在4个作用域中的数据
${u}= pageContext.findAttribute("u");
这么几把省事吗?
EL获取对于null这样的数据,在页面中表现为空字符串
${u.name}=u.getName()方法
.云算法相当于调了getter方法,点后面跟属性名
[]运算符:点能做的，它也能做; 它能做的，点不一定能做
举例:${user.name}== ${user['name']} == ${user["name"]}

JSTL
什么是JSTL
JSTL（JavaServerPages Standard Tag Library）JSP标准标签库
JSTL的作用
使用JSTL实现JSP页面中逻辑处理。如判断、循环等。



----------------------------------------------------------------------
day16
 servlet 通常通过 HTTP（超文本传输协议）接收和响应来自 Web 客户端的请求。
?  若想开发一个动态web资源(即开发一个Java程序向浏览器输出数据)，要完成2个步骤：
l  编写一个Java类，实现servlet接口。
l  把开发好的Java类部署到web服务器中。

实现javax.servlet.Servlet接口
继承javax.servet.GenericServlet类(适配器模式)
继承javax.servlet.http.HttpServlet类（模板方法设计模式）


 M：Model模型【JavaBean】
 V：View视图  【JSP】
 C：Controller控制器 【Servlet】
  JSP + Servlet + JavaBean


JSP概述
?  JSP全称是Java Server Pages，它和servle技术一样，都是SUN公司定义的一种用于开发动态web资源的技术。JSP/Servlet规范。JSP实际上就是Servlet。
 
?  JSP这门技术的最大的特点在于，写jsp就像在写html，但它相比html而言，html只能为用户提供静态数据，而Jsp技术允许在页面中嵌套java代码，为用户提供动态数据。

当访问lesson1.jsp时，会先将其编译lession1_jsp.java，然后再编译成lession1_jsp.class



function myFunction(p1, p2) {
    return p1 * p2;              // 该函数返回 p1 和 p2 的乘积
}


=====================================
AJAX 是开发者的梦想，因为您能够：
不刷新页面更新网页
在页面加载后从服务器请求数据
在页面加载后从服务器接收数据
在后台向服务器发送数据

XMLHttpRequest     HttpRequest  

 json字符串
?JSON 指的是 JavaScript 对象表示法（JavaScript Object Notation）
?JSON 是轻量级的文本数据交换格式
?JSON 独立于语言
?JSON 具有自我描述性，更易理解
Json 字典
相当于 java 的map
JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串
JSON.parse()相反

Jackson是一个简单基于Java应用库，Jackson可以轻松的将Java对象转换成json字符串和xml文档，同样也可以将json、xml转换成Java对象。Jackson所依赖的jar包较少，简单易用并且性能也要相对高些，并且Jackson社区相对比较活跃，更新速度也比较快。

jackson特点
?容易使用 - jackson API提供了一个高层次外观，以简化常用的用例。
?无需创建映射 - API提供了默认的映射大部分对象序列化。
?性能高 - 快速，低内存占用，适合大型对象图表或系统。
?干净的JSON - jackson创建一个干净和紧凑的JSON结果，这是让人很容易阅读。
?不依赖 - 库不需要任何其他的库，除了JDK。
?开源代码 - jackson是开源的，可以免费使用。

Book b1=new Book(xx,xx);
String bookjson

List->json
List<Book> list=new ArrayList<list>();
list.add();
String bookList=mapper.writeValueAsString(list);
sout(booklist);

==============================================

下午
HTML 页面
<html>
<body>

<div id="demo">
  <h2>让 AJAX 更改这段文本</h2>
  <button type="button" onclick="loadDoc()">更改文本</button>
</div>

</body>
</html>
这张 HTML 页面包含一个 <div> 和一个 <button>。

<div> 用于显示来自服务器的信息。

<button> 调用函数（当它被点击）。

该函数从 web 服务器请求数据并显示它：
Function loadDoc()

function loadDoc() {
  var xhttp = new XMLHttpRequest();
  xhttp.onreadystatechange = function() {
    if (this.readyState == 4 && this.status == 200) {
     document.getElementById("demo").innerHTML = this.responseText;
    }
  };
  xhttp.open("GET", "ajax_info.txt", true);
  xhttp.send();
} 

responseText 属性
responseText 属性以 JavaScript 字符串的形式返回服务器响应，因此您可以这样使用它：

实例
document.getElementById("demo").innerHTML = xhttp.responseText;
==============================
关于meta标签中的http-equiv属性使用介绍
meta是html语言head区的一个辅助性标签。也许你认为这些代码可有可无。其实如果你能够用好meta标签，会给你带来意想不到的效果，meta标签的作用有：搜索引擎优化（SEO），定义页面使用语言，自动刷新并指向新的页面，实现网页转换时的动态效果，控制页面缓冲，网页定级评价，控制网页显示的窗口等！ 

meta标签的组成：meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 

--------------------------------
创建 XMLHttpRequest 对象
所有现代浏览器（Chrom、IE7+、Firefox、Safari 以及 Opera）都有内建的 XMLHttpRequest 对象。

创建 XMLHttpRequest 的语法是：

variable = new XMLHttpRequest();


向服务器发送请求
如需向服务器发送请求，我们使用 XMLHttpRequest 对象的 open() 和 send() 方法：

xhttp.open("GET", "ajax_info.txt", true);
xhttp.send();

-------------------------
php也是动态的脚本语言
------------------------
么是 jQuery ？
jQuery是一个JavaScript函数库。

jQuery是一个轻量级的"写的少，做的多"的JavaScript库。

jQuery库包含以下功能：

HTML 元素选取
HTML 元素操作
CSS 操作
HTML 事件函数
JavaScript 特效和动画
HTML DOM 遍历和修改
AJAX
Utilities

为什么使用 jQuery ？
目前网络上有大量开源的 JS 框架, 但是 jQuery 是目前最流行的 JS 框架，而且提供了大量的扩展。

?jQuery 是一个 JavaScript 库,即对js的封装
?jQuery 极大地简化了 JavaScript 编程,如对节点增删改查及动画添加
?jQuery封装了异步post和 get请求
?要学习jQuery前你首先要具备HTML/CSS/JS的相关知识

很多大公司都在使用 jQuery， 例如:

Google
Microsoft
IBM
Netflix


jquery的语法
基础语法是：$(selector).action()
?	美元符号定义 jQuery
?	选择符（selector）“查询”和“查找” HTML 元素
?	jQuery 的 action() 执行对元素的操作

#div1{}
$('#div1').width(200); 
.div1{}
 $('.div1')

.................................................................................暂停一段
下阶段学习框架,web的知识就补充到这里了,SpringMVC,Struts2,hibernate
mybatis学了
ssm+ssh spring struts2 SpringMVC  hibernate mybatis springboot
SpringMVC>Struts2     mybatis=hibernate 
由于下一步就是SpringMVC,所以先学这个!
我发现应该先学spring框架,再去学组合框架
@Controller和@RequestMapping

@Controller注解就是表明这是一个Controller，且会被spring容器进行初始化。

dispatcher-servlet.xml中的扫描包配置语句：

<context:component-scan base-package="org.format.demo.controller" />
这条语句是扫描org.format.demo.controller下被@Controller(还有其他的如 @Component, @Service, @Repository)注解的那些类，并进行实例化。

@RequestMapping 顾名思义，就是请求映射。
我们看到@RequestMapping("/")中的"/"的意义就是contextPath后面的路径；也就是 http://host:port/contextPath 后面的路径。 (这里不一定都要以"/"开头，比如 "/employee"， 我们可以写成 "employee" )


JSP 表达式语言定义了一组隐式对象，其中许多对象在 JSP scriplet 和表达式中可用:
pageContext
JSP 页的上下文。它可以用于访问 JSP 隐式对象，如请求、响应、会话、输出、servletContext 等。例如，${pageContext.response} 为页面的响应对象赋值。

===========================================

首先让我们了解下MVC（Model-View-Controller）三元组的概念：

Model（模型）：数据模型，提供要展示的数据，因此包含数据和行为，可以认为是领域模型或JavaBean组件（包含数据和行为），不过现在一般都分离开来：Value Object（数据） 和 服务层（行为）。也就是模型提供了模型数据查询和模型数据的状态更新等功能，包括数据和业务。

View（视图）：负责进行模型的展示，一般就是我们见到的用户界面，客户想看到的东西。

Controller（控制器）：接收用户请求，委托给模型进行处理（状态改变），处理完毕后把返回的模型数据返回给视图，由视图负责展示。 也就是说控制器做了个调度员的工作.


JSP本质还是Servlet，最终在运行时会生成一个Servlet（如tomcat，将在tomcat\work\Catalina\web应用名\org\apache\jsp下生成），但这种使得写html简单点，但仍是控制逻辑、表现代码、业务逻辑对象调用混杂在一起

===============================================
day19
***struts的工作流程***
建立web工程,导入jar包,添加配置文件(struts.xml)文件内标签删除,但是保留各种HTTP,接下来配置struts的过滤器,在web.xml中配置Filter
<filter>
<filter-name>struts2</filter-name>
<filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class>
</filter>

<filter-mapping>
<filter-name>struts2</filter-name>
<url-pattern>/*</url-pattern>
</filter-mapping>
配置的目的是用于拦截请求,又struts的规则去处理请求,额不是以前的servlet去处理.
这点和spring MVC的在web.xml配置Dispatcher-servlet请求拦截很像,都是把请求交给struts/Dispatcher-servlet处理.然后tomcat试运行,🆗就在struts中配置.

加载tomcat,加载web.xml,实例化并初始化过滤器,加载struts.xml配置文件,web端的请求被拦截,到struts.xml配置文件的name是否相同,相同则找class,找到后实例化动作类,后调用方法,方法的返回值再比对struts里面是否name是否相同,相同则调用后面的jsp文件返回给浏览器端

s是基于过滤器,springmvc是基于servlet

控制器都是找类找方法

Struts配置文件的主要元素讲解
 package元素
作用：
?在struts2的配置文件中引入了面向对象思想，使用了分包管理。易于管理动作类。便于模块化开发动作类。
name	包的名称。必须写。且必须唯一。
extends	一般情况下需要继承struts-default包，但不是必须的。
 	不过如果不继承的话，将无法使用struts2提供的核心功能。
 	struts-default.xml中定义着struts-default这个包。
 	而struts-default.xml是在我们的struts.xml加载之前加载。
abstract	把包声明为抽象包，抽象包就是用来被继承的。

只要是没有<action>元素的包，就可以声明为抽象包。
namespace名称空间。【访问路径=名称空间+动作名称】

?name：动作名称 				
?class：动作类全名。
?method：动作类中的方法名称。默认是public String execute(){}
方法的要求： 							
1.public的 							
2.返回值必须是String 							
3.没有参数


<package  name="p1(唯一即可)" extends="struts-default" >
	<action name="login(在网页端.../login)" class="cn.clc.web.action.类名" 
method="类下的方法名">
	<result name="是否与上面的类的返回值相同">/xxx.jsp</result>
	</action>
</package>


------------------------------------------------------------------------------------------
day20
东西写在Struts下面

	name：逻辑视图的名称，对应着动作方法的返回值。默认值是success
	type：结果类型，指的就是用什么方式转到定义的页面。默认是dispatcher转发。

result中type的取值
result中type的取值有四种类型 
dispatcher	(默认值)使用请求转发，转向一个页面。
redirect	使用重定向，转向一个页面。
chain	转发到另一个相同名称空间的动作
转发到不同名称空间的动作
redirectAction	重定向到另一个相同名称空间的动作
重定向到不同名称空间的动作


只有一个Struts.xml的配置
<!-- 1.用户模块-->
<package name="user" extends="struts-default" namespace="user">
	<!-- 添加用户-->
	<action=addUser" class="cn.clc.web.UserAction" method="addUser">
		<result name="success">/xx.jsp</result>
	</action>
	<!-- 删除用户-->
	<action=deleteUser" class=cn.clc.UserAction" method="deleteUser">
		<result name="success">/xx.jsp</result>
	</action>
</package>

<!-- 2.角色模块 -->
<package name="role" extends="struts-default" namespace="role">
	<!-- 添加角色 -->
	<action name="addRole" class="cn.clc.web.RoleAction" method="addRole">
		<result name="success">/xx.jsp </result>
	</action>
	<!--删除角色-->
	<action name="deleteRole" class="cn.clc.RoleAction" method="deleteRole">
		<result name="success">/xx.jsp</result>
	</action>
</package>
---------------------

多个Struts的文件开发
cn.clc.web.action下面有Orleaction.java和Useraction.java
src下面有struts-user.xml,struts-role.xml以及Struts.xml
其中Struts.xml
<struts>
	<!--是否为开发模式.开发模式:改了配置危机,不要重启.输出更多的错误,
	value值为true-->
	<constant name="struts.devMode" value="true"></constant>
	<include file="struts-role.xml"></include>
	<include file="struts-user.xml"></include>
</struts>
struts-role.xml
<?xml version="1.0" encoding="UTF-8"?>
<struts>
<package name="role" extends="struts-default" namespace="role">
	<!-- 添加角色 -->
	<action name="addRole" class="cn.clc.web.RoleAction" method="addRole">
		<result name="success">/xx.jsp </result>
	</action>
	<!--删除角色-->
	<action name="deleteRole" class="cn.clc.RoleAction" method="deleteRole">
		<result name="success">/xx.jsp</result>
	</action>
</package>
</struts>

UserDao实现类是真实现,UserService是returnUserDao的实现类???

==========================================================
拦截器
?	1.创建个拦截器，继承Abastract方法，实现intercept方法
...
public class MyInterceptor extends AbstractInterceptor{
	public String intercept(ActionInvocation invocation) throws E
	Exception{
	Sout("拦截前");
	String invoke=invocation.invoke();
	sout(invoke);
	sout("拦截后");
	return invoke;
	}
}

2.在Struts中配置拦截器,拦截器需要配置后才能使用
<package name="p1" extends="struts-default">
<!-- 拦截器-->
<interceptors>
	<interception name="myInterception" class="cn.clc.web.MyInterception"></interception>  *n
</interceptors>

<action name="action1" class="cn.clc.web.action.Demo" method="action1"
	<!--拦截器配置,一旦配置,默认失效-->
	<interceptor-ref name="myInterceptor"> </interceptor-ref>*n
	<result>/demo01.jsp</result>
</action>
</package>

还有Demo.java
public class Demo extends ActionSupport{
	public String action1{
	return SUCCESS;
	}
}
多个拦截器运用类似上面
并且拦截器运用的场景是登录
?	首先准备四个login.jsp，main.jsp, studentList.jsp,teacherList.jsp 页面?	当登录成功后，跳转到main.jsp，main.jsp的内容可以跳转到学生和老师列表
监听拦截跳转
UserAction.java 里面有login方法
登录验证拦截器  CheckLoginIntercetor.java 从session获取用户名进行验证设置
String username=(String) session.getAttribute("username");
if(username!=null){
	return invocation.invoke();
	}
	sout("未登录过");
	return "toLoginPage";
	}
}
拦截器配制
struts.xml
<!-- 学生列表 -->
<action name="studentList" class=cn.clc.web.action.StudentAction" method="list">
	<interceptor-ref name="checkLoginInterceptor"></interceptor-ref>
	<result name="success"> /WEB-INF/studentList.jsp</result>
</action>
......但是有很多拦截器都要配制,会很麻烦

案例中的问题
?	问题：由于我们写了自己的拦截器，默认的拦截器不起作用了。
?	举个简单的例子，就是不可以接收请求参数
?	解决办法:把默认拦截器加到配制里面

<!-- 学生列表 -->
<action name="studentList" class=cn.clc.web.action.StudentAction" method="list">
	<interceptor-ref name="defaultStack"></interception-ref>
	<interceptor-ref name="checkLoginInterceptor"></interceptor-ref>
	<result name="success"> /WEB-INF/studentList.jsp</result>
</action>

=========================================================
Struts2的文件上传
<s:file>
?	Struts也提供了内置标签用于文件上传<s:file>，我们称为文件选择域
?	与html的标签<input tyle=”file”>是一样用的
?	文件上传的必要前提条件
?	表单必须是post方法
?	enctype类型必须为multipart/form-data
还需要配制上传失败的回显,一般是一个类加上Struts配制文件里面的配置
此外,还有文件的下载
=============================
contextMap 
动作类的生命周期
?	明确：
?	动作类是多例的，每次动作访问，动作类都会实例化。所以是线程安全的。
?	与Struts1的区别是，struts1的动作类是单例的。

2、请求数据的存放
?	问题：			
?	每次请求时，都会产生一些请求数据，这些数据存放到哪里去了？ 		
?	明确： 			
?	在每次动作执行前，核心控制器StrutsPrepareAndExecuteFilter都会创建一个ActionContext和ValueStack对象。且每次动作访问都会创建。 			
?	这两个对象存储了整个动作访问期间用到的数据。
?	并且把数据绑定到了线程局部变量（ThreadLocal）上了。所以是线程安全的
还有OGNL.
专门研究SpringMVC
=====================================================
day20 -afternoon
（1）过滤器(Filter)：它依赖于servlet容器。在实现上，基于函数回调，它可以对几乎所有请求进行过滤，但是缺点是一个过滤器实例只能在容器初始化时调用一次。使用过滤器的目的，是用来做一些过滤操作，获取我们想要获取的数据，比如：在Javaweb中，对传入的request、response提前过滤掉一些信息，或者提前设置一些参数，然后再传入servlet或者Controller进行业务逻辑操作。通常用的场景是：在过滤器中修改字符编码（CharacterEncodingFilter）、在过滤器中修改HttpServletRequest的一些参数（XSSFilter(自定义过滤器)），如：过滤低俗文字、危险字符等。


（2）拦截器（Interceptor）：它依赖于web框架，在SpringMVC中就是依赖于SpringMVC框架。在实现上,基于Java的反射机制，属于面向切面编程（AOP）的一种运用，就是在service或者一个方法前，调用一个方法，或者在方法后，调用一个方法，比如动态代理就是拦截器的简单实现，在调用方法前打印出字符串（或者做其它业务逻辑的操作），也可以在调用方法后打印出字符串，甚至在抛出异常的时候做业务逻辑的操作。由于拦截器是基于web框架的调用，因此可以使用Spring的依赖注入（DI）进行一些业务操作，同时一个拦截器实例在一个controller生命周期之内可以多次调用。但是缺点是只能对controller请求进行拦截，对其他的一些比如直接访问静态资源的请求则没办法进行拦截处理。
 
过滤器属于sevlet规范,而拦截器属于spring框架.
拦截器是前端控制器收到请求,再掉控制器
容器收到请求,先调过滤器,再掉servlet


1.控制器部分
组件扫描,注解扫描,视图配置--springmvc.xml
<context:compent-scan base-package="controller"/>
<mvc:annotation-driven/>
<bean class="org.springfram...>
  <property name="prefix" value="">
  <property name="suffix" vaule="">
</bean>

<util:propertires id="config" location="classpath:db.properties"/>

<!--配置连接池-->
<bean id="ds" class="org.apache.commons.dbcp.BssicData"
  destory-method="close">
<property name="driverClassName"
value="#{config.driver}"/>
<property name="url"
value="#{config.url}"/>
<property name="username"
value="#{config.username}"/>
<property name="password"
value="#{config.password}"/>
<!-- 配置拦截器-->
<mvc:interceptors>
  <mvc:interceptor>
       <mvc:mapping path="/**"/>
       <mvc:exclude-mapping path="/toLogin.do"/>
       //排除就是不拦截此部分
       <mvc:exclude-mapping path="/login.do"/>
       <bean class="com.clc.interceptors.SomeInterceptor">
  </mvc"interceptor">
</>
1.2如果有多个拦截器,按照配置的先后顺序执行
在spring的xml配置文件里面定义
<bean class="">
  <property name="exceptionMapping">
     <props>
         <prop key="java.lang.Exception">error</>
         <prop key="com.clc.TimeoutException"(异常类型)>login)(视图界面)</>
      </>
   </>
</>

还有web.xml
<servlet-mapping>
  <servlet-name>springmvc</>
  <url-pattern>*.do</>
2.处理器部分
controller包下开始创建处理器
@Controller
public class helloController{
	
	@ExceptionHandler
	//这是一个异常处理方法,这是除了在springmvc.xml配置异常的第二种方法.
	//ex:是其他方法所抛出的异常.
	public String execute(HttpServletRequest request,Exception ex){
	request.setAttribute("ex",ex);
	//可以根据异常类型的不同返回不同视图名
	if(ex instanceof NumberFormatException){
	request.setAttribute("errorMsg","请输入正确的数字");
	}else if(ex instanceof StringIndexOutOfBounce)
	request.setAttribute("errorMsg","下标越界");
	//在error.jsp页面#{errorMeg}即可
	return "error";
	else return "system_error";
	}//然后其他的Controller继承BaseController类
	@RequestMapping("/hello.do")
	public String hello(){
		System.out.println("hello()");
		return "hello";
	}
}

2.1现在创建一个拦截器,要求DispatcherServlet先调用拦截器
HandlerInterceptor和filter一样,可以有三个方法
public class SomeInterceptor implements HandlerinterCeptor{

	public boolean preHandle(req,res,Object arg2){
	HttpSession session=req.getSession();
	Object obj=session.getAttribute("admin");
	if(obj==null){
	res.sendRedirect("toLogin.do");
	return false;
	}
      return false;
}


return true;}
	前段控制器收到请求后,会先调preHandle方法
	true继续调,false停止调.第三个参数是描述处理器方法的一个对象.
	(秘书允许见局长)
	
	(处理器/Controller的方法已经执行完毕,正准备将处理结果返回前端控制器之前)
	(执行postHandle方法,可以在该方法里修改ModelAndView的返回结果)
	多第四个参数 ModelAndView mav
	public void postHandle(,,,ModelAndView mav)throws Exception{}

	(最后执行的方法,当prehandle为true时执行)
	(ex:是处理器所抛出的异常,可以写一个拦截器来处理这些异常)
	public void afterCompletion()throws Exception(,,,Exception ex){}
	
}
------------------------------------------------------------------------------
spring+JDBC
step1.添加spring的配置文件
step2.配置JdbcTemplate.
step3.调用JdbcTemplate提供的方法来访问数据库,依赖注入
通常将Jdbctemplate注入到DAO. 这时候我们需要建一张表
create table emp(
   id number(8)primary key,
   name varchar2(50),
    age number(3));
create sequence emp_seq;
----------------------------------------------------------------------------
applicationContext.xml 和db.properties一起放在resource包下
<util:propertires id="config" location="classpath:db.properties"/>
 
<!--配置连接池-->
<bean id="ds" class="org.apache.commons.dbcp.BssicData"
  destory-method="close">
<property name="driverClassName"
value="#{config.driver}"/>
<property name="url"
value="#{config.url}"/>
<property name="username"
value="#{config.username}"/>
<property name="password"
value="#{config.password}"/>

<!--配置JdbcTemlate-->
<bean id="jt" class="org.springframework.jdbc.core.JdbcTemplate">
	<property name="dataSource"
	ref="ds"/>
</bean>

<!-- 配置组件扫描 -->
<context:component-scan  base-package="dao"/>
Emp.java  entity
public class Emp implement Ser{
private Integer id;
private String name;
private Double age;get/set/toString}

EmpDAO.java dao包
@Repository("empDAO")
public class EmpDAO{
    @Resource(name="jt")
     private JDbcTemlate tempate;
    public void save(Emp emp){ 
      String sql="insert into emp"+"Values(emp_seq.nextval,?,?)";
     Object[] args=new Object[]{emp.getName(),emp.getAge()};//对象数组的作用,给参数赋值.
    template.update(sql,args);//调用末班对象的方法 
//看不到任何的底层的连接 
}

public class TestCase{
  //启动spring容器
  ApplicationContext ac=new ClassPathXmlApplicationContext("applicationContext.xml");
  EmpDAO dao=ac.getBean("empDAO",EmpDAO.class);
  Emp emp=new Emp();
  emp.setName("Giving king");
  emp.setAge(new Double(22));
  dao.save(emp);
}


------------------------------------------------------------
面向切面:
Spring AOP 可以劫持一个执行的方法，在方法执行之前、执行中或执行之后添加额外的功能
AOP可以帮我们实现日志记录，性能统计，安全控制，事务处理，异常处理等功能

控制反转:
通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。

那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。

DI(依赖注入)
　　IOC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。
那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射(reflection),它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。
1.导入spring的包(beans,core,context,expression)+(common-logging.jar)
2.写个简单的Service,比如UserServiceImpl 并在main方法调用
3.SpringIOC控制反转建立实例
	3.1写了配置文件beans.xml
	3.2离线配置文件约束提示的配置
	3.3Beans.xml文件的配置
4.从beans.xml获取bean,也就是加载路径
ApplicationContext context=new ClassPathXmlApplication("com/clc/spring/beans.xml");
2.根据Id 获取bean
UserService userService =(UserService)context.getBean("userServiceId");

userService.add();
------------------------------
启动spring容器?
1.导包(spring-webmvc)
2.添加配置文件
3.启动spring容器
如何创建对象?
1.也就是装配Bean.xml的三种方法
----------------------------------
加载Spring容器的三种办法:(启动spring容器)
1.查询类路径加载配置文件
ApplicationContext context=new ClassPathXmlApplication("com/clc/spring/beans.xml");

第二种.文件系统路径获取配置文件
ApplicationContext context=
new FileSystemXmlApplicationContext("...\\beans.xml");

装配Bean.xml的三种方式(创建对象)
1.使用构造方法实例化(重要)
<!-- 第一种方式: new 实现类-->
id属性:bean的名称,要求唯一
class属性:类的全限定名
<bean id="userService1"class="com.gyf.service.UserServiceImpl"></bean>
2.使用静态工厂方法实例化
<bean id="userService2"class="com.gyf.service.UserSereviceFactory1" factory-method="createUserService"></bean>
3.通过实例化工厂的方法
<bean id="factory2" class="com.gyf.service.UserSereviceFactory2"></bean>

<bean id="userService3" factory-bean="factory2" factory-method="createUserService"></bean>

@Test
public void test1(){
    ApplicationContext context = new ClassPathXmlApplicationContext("beans3.xml");

//new 对象
    //IUserService userService1 = (IUserService) context.getBean("userService1");
    //userService1.add();


    //静态工厂
    //IUserService userService2 = UserSereviceFactory1.createUserService();
    //IUserService userService2 = (IUserService) context.getBean("userService2");
    //userService2.add();


    //实例工厂
    //1.创建工厂
   // UserSereviceFactory2 factory2 = new UserSereviceFactory2();
    //IUserService userService3 = factory2.createUserService();
--------------------------------------------------------------------
day21 -spring
一句话:spring是装对象的容器
IUserService userService3 = (IUserService) context.getBean("userService3");
    userService3.add();
}
spring入门案例:

建造一个service类,在Beans.xml配置文件配置,加载配置文件,加载beans.xml文件的配置
class UserviceImpl implements UserService{
public void add(){
sout("添加用户!");
}
public static void main (String[] args){
UserService u=new UserServiceImpl();
u.add();
}
}

然后在beans.xml文件加上
<!-- 配置一个Bean -->
<bean id="userServiceId" class="com.clc.com/clc/spring/上面那个service类"></bean>
最后
从beans.xml获取bean
public void test(){
ApplicationContext context=new ClassPathXMLApplicationContext("xxx.xml");

UserService userService=(UserService)context.getBean("来自beans.xml的配置文件的那个<bean> 的id值");
-------------------------------------------------------------------
控制反转就是在service中去掉main函数,在配置beans.xml时加上
<bean> <property name="name" value="zhangsan"></property></bean>
相当于 UserService u=new UserServiceImpl();
u.setName("zhangsan");
依赖注入是控制反转的一个方式,自己不去new对象,把这个过程交给了spring框架

在spring框架里面可以有多个xxx.xml
现在有AB两个类,B类正常,A类里面有私有成员变量B b,以及方法setB(B b)
property元素:表示使用set方法来注入依赖关系,其中name属性指定属性名,ref属性
指定属性值(被注入的bean的id)
<bean id="b1" class="ioc.B"/>
<bean id="a1" class="ioc.A">
     <property name="b" ref="b1"/>
</bean>

依赖注入是控制反转的一个方式,自己不去new对象,把这个过程交给了spring框架
依赖注入两种方式:1.set方法,构造器 

构造器注入
1.ab类都有,在A类里面写一个构造器
2.然后再建立一个ioc2.xml,
<!--constructor-args元素:用来配置构造器方式的注入,其中,
index属性指定参数的下标(从0开始).-->
<bean id="a1" class="ioc2.A">
   <constructor-args index="0" ref="b1"/>
</bean> 

自动装配
指的是spring容器一句某种规则,自动建立对象之间的依赖关系
(仍然需要写set或者是构造器,)
autowire属性:表示让容器自动装配
该属性有如下三个值:
byName: 容器依据属性名查找对应的bean,然后调用对应的set方法完成注入
注:a.如果找不到对应的bean,然后调用对应的set方法来完成注入.
byType:容器一句属性的类型来查找对应的bean,然后调用对应的set方法来完成注入.
toString方法一般是测试输出打印信息用
两个类,一个waiter和一个restaurant,后者类的属性有前者
<bean id="wt" class="ioc.Waiter"/>
<bean id="reat" class="ioc.Restaurant" autowire="byName"/>
byName依据属性名查找对应的bean,去Restaurant类中找wt,去<bean>找对应
的值来完成注入.
<bean id="wt1" class="ioc.Waiter"/>
<bean id="rest" class="ioc.Restaurant" autowire="byType"/>
----------------------------------------------------------------------------
<property name="score>
  <map>
     <entry key="english" value="60"/>
     <entry key="english" value="34"/>
  </map>
</property>

<property name="interest">
  <set>
      <value>1</value>
      <value>2</value>
      <value>3</value>
   </set>
</property>

<property name="place">
  <list>
      <value>1</value>
      <value>2</value>
      <value>2</value>
   </list>
</property>

命名空间 namespace 区分同名,让在xml配置里面可以重名
   <!--将集合类型的值配置成一个bean -->

   <util:list id="cityBean">
      <value>1</value>
      <value>2</value>
      <value>2</value>
   </util:list>
<!-- 引用的方式注入集合类型的值  -->
<bean id="vb2" class="xxx.ValueBean" >
    <property name="city"  ref="cityBean"/>
    <property name="interest"  ref="interestBean"/>
    <property name="score"  ref="scoreBean"/>
</bean>
-------------------------------------------------------------------------------------


***温习一下加载spring容器***
1.类路径获取配置文件
ApplicationContext context=new ClassPathXmlApplicationContext(".xml");
2.文件系统路径获取配置文件
ApplicationContext context=name FileSystemXmlApplicationContext(".xml");

***温习装配beans.xml***
所谓装配就是写一个bean标签 
<bean id="userService1" class="com.clc.UserServiceImpl">
-----------------------------
下午
注入Spring 表达式,和EL类似,可以读取一个bean对象/集合中的数据
 对<property>进行统一编程，所有的内容都使用value
 <property name="" value="#{表达式}"> value=#{vb1.name} =vb1.get(name)
#{123}、#{'jack'} ： 数字、字符串
#{beanId}	：另一个bean引用
#{beanId.propName}	：操作数据
#{beanId.toString()}	：执行方法
#{T(类).字段|方法}	：静态方法或字段
bean的id.属性名
List的下标
Map的key properties文件中的key
=========================================

******注解注入*******
注解:就是有个类,使用@注解名称
开发中:使用注解 取代  xml配置文件.
<!-- base-package属性:指定要扫描的包名,spring容器会扫描该报下机器子包下的
所有的类,如果类前有特定的注解,spring容器会将其纳入容器进行管理(相当于配置了一个bean元素)>
 <context:component-scan   base-package="annotation ">

只有组件类定义前面有以下注解标记时,才会扫描到spring容器
@Component  通用注解
@Named         通用注解
@Repository    持久化层组件注解
@Service         业务层组件注解
@Controller     控制层组件注解 


@Autowired和@Qualifier支持set注入和构造器注入
@Autowired
public void setWt(
  @Qualifier("wt")    Waiter wt){
System.out.println("setWt()");
this.wt=wt;
}
//告诉容器调set方法来注入,并且在这个类前面加@Component
除非保证waiter是单例的
@Resource
只支持set方法的注入 

@Value
可以使用该注解来注入基本类型的值
也可以使用该注解;AI使用spring表达式
该注解可以添加到属性前,或者添加到对应的set方法前.
=========================================

AOP采用横向抽取机制,取代传统纵向继承体系重复性代码
SpringAOP使用纯Java实现,不需要专门的编译过程和类加载器,在运行的
通过代理的方式向目标类植入增强代码.
AspectJ是一个基于java的语言的AOP框架,spring2.0开始,SpringAOP引入了
对AspectJ的支持,AspectJ扩展了java语言,提供了一个专门的编译器,在
编译时候提供横向代码的植入.
Proxy
AOP实现原理
a aop底层采用代理机制实现
b 接口+实现类:spring 采用jdk的动态代理Proxy.
c 实现类:spring 采用了cglib字节码增强.
AOP:面向切面编程,不修改原有代码,给系统增加新的功能.

在一个target类运行的时候,消息类用Proxy代理的方法插入进去,
这样在目标类运行的时候,就会被代理proxy拦截自由的加入我想添加额东西.

c3p0与dbcp区别
dbcp没有自动回收空闲连接的功能
c3p0有自动回收空闲连接功能

?	C3P0是一个开源的JDBC连接池，它实现了数据源和JNDI绑定，支持JDBC3规范和JDBC2的标准扩展。目前使用它的开源项目有Hibernate，Spring等。


手动代理,jdk动态代理,不用配置xml
spring编写半自动在<bean>下配置
spring AOP全自动编程在<aop:config>
=================================================
day21 
#springmvc的五大组件
##dispatcherServlet(前段控制器)
接收请求,依据HandlerMapper的配置调用相应的模型进行处理
##HandlerMapper
包含请求路径与模型的对应关系.
##Controller
负责处理业务逻辑.
##ModelAndView
封装了处理结果
##VIewResolver(视图解析器)
DispatcherServlet依据VIewResolver的解析,
调用真正的视图对象来生成相应的页面.
注:五大组件的关系
a.DispatcherServlet收到请求之后,依据HandlerMapper的配置,调用相应的Controller
来处理.
b.Controller将处理结果封装成ModelAndView对象,然后返回给DispatcherServlet
对象,然后返回给DispatcherServlet.
c.DispatcherServlet依据ViewResolver的解析,调用相应的视图对象来 生成页面.

====================================================
springmvc 入门案例成功
1.在web.xml里面配置DispatcherServet,所有请求由SpringMVC 管理
 <servlet>
        <servlet-name>DispatcherServlet</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <load-on-startup>1</load-on-startup>
    </servlet>

    <servlet-mapping>
        <servlet-name>DispatcherServlet</servlet-name>
        <url-pattern>*.do</url-pattern>  //在访问服务器的时候,后缀.do全部拦截
    </servlet-mapping>
2.在WEB-INF里面创建一个DispatcherServlet-servlet.xml,
名字必须是固定的,WEB-INF会自动执行这个文件
开始在里面配置
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
		http://www.springframework.org/schema/beans/spring-beans-3.2.xsd 
		http://www.springframework.org/schema/mvc 
		http://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd 
		http://www.springframework.org/schema/context 
		http://www.springframework.org/schema/context/spring-context-3.2.xsd 
		http://www.springframework.org/schema/aop 
		http://www.springframework.org/schema/aop/spring-aop-3.2.xsd 
		http://www.springframework.org/schema/tx 
		http://www.springframework.org/schema/tx/spring-tx-3.2.xsd">
		
</beans>
在上面加
1.增加URL处理映射器 2.增加处理器适配器,他会去执行Controller
3.增加一个控制器,UserController 4.增加视图解析器,前置后置防止目录

3.创建Controller控制器(在src建立包,包下建立类) implements Controller
ModelAndView mv=new ModelAndView("选择你的那个jsp");
mv.addObject("这个参数要和你的jsp的那个变量相同","传过去参数");

4.创建userList.jsp页面(在WEB-INF目录下views视图,接着创建user包,包里放jsp)
和Controller控制器类的变量相同

运行流程:
请求->DispatcherServlet(拦截器过滤)->BeanNameUrlHandlerMapper()寻找Controller->再去找处理器适配器来执行Controller->视图解析器来查找jsp路径
->响应请求

-----------------------通过访问的路径找到对于的控制器
第二种,在URL用上<property><props><prop key="">
然后在适配器里面不用name,改用id与上面的key所对应
第三种,默认类<bean class="">即可
不过都挺复杂,最后可以通过使用注解来配置URL映射器和适配器

Command命令控制器 SpringMVC通过命令设计模式接收页面参数
commandservice就是用来接收jsp传过来的参数,不过,我猜测这个service
肯定会有取代,比如注解,写了注解就不用写Dispatcher-servlet的映射,适配,控制器,但是控制器还是要写的,jsp页面还是要写的
public class CommandCOntroller extends AbstractCommandController {
    //指定那个bean来接收参数
    public CommandCOntroller() {
        this.setCommandClass(User.class);
    }

    @Override
    protected ModelAndView handle(HttpServletRequest request, HttpServletResponse response, Object o, BindException errors) throws Exception {
        User user = (User) o;
        System.out.println(user);
        ModelAndView mv = new ModelAndView();
        mv.addObject("user", user);
        mv.setViewName("/user/info");
		return mv;
    }
}
------------------------------------------------------------------------------
注解开发入门案例
<!-- 1.配置注解扫描位置 -->
<context:component-scan base-package="com.gyf.backoffice.web.controller"/>
		
<!-- 2. 配置处理器映射，通过注解来查找 -->
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/>
<!-- 3.配置注解处理适配器来执行控制器的方法 -->	
<bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter"/>
			
<!-- 配置springmvc视图解析器
			视图解析器解析的视频路径为：前缀 + 后缀 -->
<bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
<property name="prefix" value="/WEB-INF/views"/>
	<property name="suffix" value=".jsp"/>
</bean>
转发&重定向
//转发到同一个控制器
@RequestMappering("test")
public String test(){
	return "forward:list.do";
}
//转发到不同的控制器的方法
@Controller
@RequestMapping("/stu")
public class StudentController{

//转发到不同控制器的方法
@RequestMapping("test")
public String test(){
	return "forward:/user/list.do";
	}
}

####重定向,只需要把forward改成redirect即可
-------------------------------------------------------------------------------
1.导包
2.配置文件
3.配置Dis[atcherServlet
4.COntroller
   @Controller
    多个方法
   String ModelAndView
   @RequestMapping
5.jsp
6.添加配置:
   <!-- 把某个包中有注解的类扫描到程序中 -->
   <context:component-scan base-package>
   <!-- 启用注解 -->
   <mvc:annotation-driven/>
   <!-- 默认对静态资源的访问 -->
   <mvc:default-servlet-handler/>
   <!-- 配置根视图 -->
   <mvc:view-controller path="/com/tnr" view-name="redirect:/login"/>
 
----------------------------------------------------------------------------
8-26
1.服务器如何保存并返回一个网页?
1)静态网页
-无论谁看都一样
-比如百科.新闻
-服务器存HTML
2)动态网页
-不同人看到的不同
-服务器保存一个组件,动态给每个用户拼网页
在java语言中这个组件就是servlet
>组件:满足规范的对象

###2.Servlet的特点
-是服务器端的组件
-可以动态拼资源
-满足sun的规范

####3.服务器:
和浏览器平级的软件

举例:
-Tomcat()Apache0 开源免费
术语:处理HTTP协议


##3.开发Servlet
###1)编写Servlet
-创建package
-创建一个类,名字为XxxServlet
-继承HTTPServlet,从而间接实现了Servlet
-重写父类的service()

###2)配置Servlet
-先声明类,取别名
-在通过别名引用此类,给他去一个访问路径

###3)配置tomcat,然后AI浏览器输入地址访问

web.xml和XxxxSevlet都会在tomcat里面
/项目名/ts,浏览器像服务器发请求
在tomcat找项目名,然后在此项目下找web.xml,读取配置文件找<uri-parttern
> 最终找到那个类并运行

sun规矩 :你写servlet必须实现HttpServlet

500:类名有误-代码有误
404:找不到资源
405:方法申明有误

----------------------------
###1.浏览器与服务器 的传输协议规定
HyperText Transfer Protocol
W3c(万维网联盟)指定的易总应用层 的用来浏览器与web服务器值减去如何通信以及通信数据格式

###2.如何通信
-建立连接
-发送请求
-接收响应
-断开连接
>一次请求一次连接,降低服务器的压力

###3.数据格式
####1)请求数据
请求行(请求的基本信息)+消息头(请求的具体描述)+实体内容(具体的业务描述)
####2)响应数据
状态行+消息头+实体内容

####4对开发者要求
提供具体的实体内容
并且会使用request和response
=====================================
8-27
1.写实体类(entitry)
2.写Dao+Impl(Dao)
3.Servlet(Web) 接收业务,处理业务,输出响应

浏览器访问服务器的时候,获取并加载网页的时候,包含多次请求
WEB-INF具有傲虎作用,只有转发才能访问
静态资源是直接访问的,放在web_INF里无法直接访问,直接放在webAPP即可

创建拦截器类filter实现接口
LogFilter看作是前台,负责接待办不办卡,web.xml配置里面多个filter
一个业务,一个filter,过滤敏感词的filter,日志filter
-----------------------------------------------------------------------------
9-5
抛出异常,就是在catch里面,throw new RuntimeException("");
原来hiberate生成的代码又臭又长,性能差.mybatis容易学
 编程步骤
1.导包
mybatis ojdbc 包3个包mybatis:3.2.8,ojdbc14:10.2.0.4.0驱动,junit:4.12单元测试
2.添加配置文件,SqlMapCOnfig.xml
<configuration ><environment ><dataSource><property name "dirver" 
value="oracle.jdbc.Oracle."></></>这里是配置数据库连接池
<!--映射文件的位置-->用来写sql语句的
<mappers><mapper resource="com/clc/dao/EmpMapper">
</mapper>
</configuration>
3.写实体类,属性名与表的字段名要求一样,大小无所谓
package entirty;
public class Emp{
 private Integer id;
 private String name;
 private Double age;+get/set/toString()方法
}
4.写映射文件
EmpMapper.xml,一个实体类对应一个映射文件,过于复杂与麻烦,我猜有优化.
<mapper namespace="test">
   <insert id="save"
       parameterType="entity.Emp">
       INsert into emp vaule()
</insert>

(1)Mapper映射器(接口)
符合映射文件要求的接口
mybatis会遭到实现一个符合该接口要求的对象.
###要求:
a.接口方法的名称与映射文件中的sql的id要一样.
b.方法的参数类型要与映射文件中的parametertype一致.
c.方法的返回类型与映射文件的resultType一致
d.映射文件的namespace必须等于Mapper映射器的权限定名.
package dao;

public interface EmpDAO{
  public void save(Emp emp);	
}
然后是测试代码
---------------------------------------------------------------------
9-10
阿贾克斯
js+xml
##利用浏览器提供的特殊对象(XMLHTTPRequest,也可以称为ajax对象)向服务器发送异步请求.
服务器返回部分数据,浏览器利用这些数据对当前页面进行部分更新.
##异步请求:发送请求的同时,浏览器不会销毁当前的页面,用户仍然可以对当前页面做其他操作.
###
function getXhr(){
 var xmlhttp;
            if(window.XMLHttpRequest){
                //  IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码
                xmlhttp = new XMLHttpRequest();
            }else{
                // IE6, IE5 浏览器执行代码
                xmlhttp =  new ActiveXObject("Microsoft.XMLHTTP");
            }
}
####ajax对象的几个重要的属性
a.onreadystatechange:用来绑定一个事件处理函数,用来处理readstatechange事件
b.readState:有5个值,表示ajax的通信状态,4时表示ajax对象已经获得了服务器返回的所有数据.

##########编程步骤
step1.获取ajax对象
比如:var xhr=getXhr();
step2.发送请求(get/post)
同步(发送请求时,浏览器会说的当前页面,用户不能进行任何操作)
a.xhr.open('get','check_uname.do?name=tom',true);
b.xhr.onreadystatechane=f1;事件绑定
c.xhr.send(null);
step3.编写服务器端的程序
注:不需要返回完整的页面,只需要返回部分数据(文本)
step4.编写事件处理函数
function f1(){
	//先获取服务器返回的数据
	if(xhr.readState==4 && xhr.status==200){
	var txt=xhr.responText;
	...
	}
	//利用这些数据更新页面
}

###JSON(javascript object notation)
是一种轻量级的数据交换格式
数据交换:将要交换的数据先转换成一种与平台无关的数据格式,然后交给接收方处理
##表示一个由对象组成的数组


Stock s=new Stock();
s.setCode("");s.setName("");
JSONObject jsonObj=JSONObject.fromobject();
String jsonStr=jsonObj.toString();
sout(jsonStr);

//多个对象组成的数组或者集合转成字符串
List<Stock> stock=
new ArrList<Stock>();
for(0-2){
Stock s=new Stock();
s.setCode(""+i);
s.setName(""+i);
s.setPrice(10+i);
stocks.add(s);
JSONObject jsonObj=JSONObject.fromobject(stocks);
String jsonStr=jsonObj.toString();
sout(jsonStr);
}

#Jquery对ajax的支持
##!1)$.ajax()方法
用法:<br/>

(1)$.ajax({});
说明:
{}是一个用来描述请求选项参数的对象.常见的选项参数有如下几个:
url:请求地址
data:请求参数,有两种格式
type.请求字符串,(get/post)
dataType:服务器返回的数据的类型:
text:文本数据
json:json字符串
html:HTML文档
xml:xml文档
scprpt:javascript脚本

success:时间处理函数(当服务器处理正常.用来处理服务器返回的数据)
error:事件处理函数(当服务器处理异常,用来服务器发挥的数据)
(2)load()
作用:向服务器发送异步请求,然后将服务器返回的数据直接添加到符合的节点之上
用法:
$obj.load(url,[data]);
注:url:请求地址,data:请求参数
------------------------------------------------------------------------------
##cmmi,前身CMM软件成熟的模型,认证.
ajax发送请求,事件绑定,获取参数,$.ajax({})发送请求
服务器处理,DispatchServlet-HandlerMapper-Controller-Service-Dao-DB

Controller里面添加@ResponseBody可以实现JSON输出
事件绑定:
静态绑定:元素.click(function(){})
动态绑定:父元素.on("click","li",fn(){})
触发特效
元素.click();


-------------------------------------------------------------------------------------
注解总结
@Aspect  声明切面，修饰切面类，从而获得 通知。
通知
	@Before 前置
	@AfterReturning 后置
	@Around 环绕
	@AfterThrowing 抛出异常
	@After 最终
切入点
	@PointCut ，修饰方法 private void xxx(){}  之后通过“方法名”获得切入点引用

